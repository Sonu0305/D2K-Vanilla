import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import dash
from dash import dcc, html, Input, Output, State, callback
import dash_bootstrap_components as dbc
from datetime import datetime, timedelta
import joblib
import warnings
warnings.filterwarnings('ignore')

# Load data (these would be generated from your preprocessing script)
try:
    # Load the datasets generated by your script
    task_df = pd.read_csv(r'output\kaggle\working\facility_tasks_dataset.csv')
    daily_stats = pd.read_csv(r'output\kaggle\working\dashboard_daily_stats.csv')
    team_stats = pd.read_csv(r'output\kaggle\working\dashboard_team_stats.csv')
    task_type_stats = pd.read_csv(r'output\kaggle\working\dashboard_task_type_stats.csv')
    building_stats = pd.read_csv(r'output\kaggle\working\dashboard_building_stats.csv')
    heatmap_data = pd.read_csv(r'output\kaggle\working\dashboard_hourly_heatmap.csv')
    monthly_heatmap = pd.read_csv(r'output\kaggle\working\dashboard_monthly_heatmap.csv')
    forecast_results = pd.read_csv(r'output\kaggle\working\task_forecast_results.csv')
    anomaly_results = pd.read_csv(r'output\kaggle\working\task_anomalies.csv')
    
    # Load ML model and related data
    model_data = joblib.load(r'output\kaggle\working\facility_task_prediction_model.pkl')
    best_model = model_data['model']
    scaler = model_data['scaler']
    encoder = model_data['encoder']
    numerical_features = model_data['numerical_features']
    categorical_features = model_data['categorical_features']
    
    # Load SHAP values if available
    try:
        shap_data = joblib.load(r'output\kaggle\working\task_shap_values.pkl')
        feature_importance = shap_data['mean_importance']
    except:
        feature_importance = None
        
except FileNotFoundError:
    # Sample data for demonstration if files don't exist
    print("Using sample data for demonstration")
    
    # Generate synthetic data for the demo
    # This is just for demonstration purposes if the user hasn't run the full data processing
    # In a real scenario, you'd use the actual processed data files
    
    # Create dates for the past year
    end_date = datetime.now().date()
    start_date = end_date - timedelta(days=365)
    dates = pd.date_range(start=start_date, end=end_date, freq='D')
    
    # Sample daily stats
    daily_stats = pd.DataFrame({
        'date': dates,
        'miss_rate': np.random.uniform(5, 25, len(dates)),
        'task_count': np.random.randint(30, 100, len(dates)),
        'on_time_rate': np.random.uniform(60, 95, len(dates))
    })
    
    # Sample team stats
    teams = ['Maintenance A', 'Maintenance B', 'HVAC Team', 'Electrical Team', 
             'Plumbing Team', 'Security Team', 'Janitorial Team']
    team_stats = pd.DataFrame({
        'team': teams,
        'miss_rate': np.random.uniform(5, 25, len(teams)),
        'task_count': np.random.randint(100, 1000, len(teams)),
        'on_time_rate': np.random.uniform(60, 95, len(teams))
    })
    
    # Sample task type stats
    task_types = [
        'Preventive Maintenance', 'Corrective Maintenance', 'Safety Inspection',
        'Cleaning', 'Filter Replacement', 'Equipment Calibration', 'Security Check',
        'HVAC Service', 'Plumbing Repair', 'Electrical Inspection', 'Pest Control',
        'Landscape Maintenance', 'Fire System Check', 'Elevator Maintenance'
    ]
    task_type_stats = pd.DataFrame({
        'task_type': task_types,
        'miss_rate': np.random.uniform(5, 25, len(task_types)),
        'task_count': np.random.randint(50, 500, len(task_types)),
        'on_time_rate': np.random.uniform(60, 95, len(task_types))
    })
    
    # Sample building stats
    buildings = [f'Building_{i}' for i in range(1, 6)]
    building_stats = pd.DataFrame({
        'building': buildings,
        'miss_rate': np.random.uniform(5, 25, len(buildings)),
        'task_count': np.random.randint(200, 800, len(buildings)),
        'on_time_rate': np.random.uniform(60, 95, len(buildings))
    })
    
    # Sample heatmap data
    days = list(range(7))
    hours = list(range(7, 19))
    heatmap_data = pd.DataFrame([
        {'day_of_week': day, 'scheduled_hour': hour, 'miss_rate': np.random.uniform(0, 30)}
        for day in days for hour in hours
    ])
    
    # Sample monthly heatmap
    months = list(range(1, 13))
    monthly_heatmap = pd.DataFrame([
        {'scheduled_month': month, 'day_of_week': day, 'miss_rate': np.random.uniform(0, 30)}
        for month in months for day in days
    ])
    
    # Sample forecast data
    forecast_dates = pd.date_range(start=end_date, periods=30)
    forecast_results = pd.DataFrame({
        'ds': forecast_dates,
        'yhat': np.random.uniform(10, 20, len(forecast_dates)),
        'yhat_lower': np.random.uniform(5, 10, len(forecast_dates)),
        'yhat_upper': np.random.uniform(20, 30, len(forecast_dates))
    })
    
    # Sample anomaly data
    anomaly_results = pd.DataFrame({
        'scheduled_date': dates[:90],
        'task_missed': np.random.uniform(0, 0.3, 90),
        'anomaly': np.random.choice([0, 1], size=90, p=[0.9, 0.1]),
        'anomaly_score': np.random.uniform(-0.5, 0.5, 90)
    })
    
    # Create fake feature importance
    feature_names = [
        'concurrent_tasks', 'resource_availability', 'task_complexity', 
        'priority_level', 'team_daily_workload', 'is_weekend',
        'scheduled_hour', 'building_daily_workload', 'daily_type_count',
        'day_of_week', 'rolling_miss_rate', 'estimated_duration'
    ]
    feature_importance = pd.DataFrame({
        'feature': feature_names,
        'importance': np.random.uniform(0, 0.5, len(feature_names))
    }).sort_values('importance', ascending=False)

# Prepare data for dashboard
if 'date' in daily_stats.columns:
    daily_stats['date'] = pd.to_datetime(daily_stats['date'])
    
if 'scheduled_date' in anomaly_results.columns:
    anomaly_results['scheduled_date'] = pd.to_datetime(anomaly_results['scheduled_date'])
    
if 'ds' in forecast_results.columns:
    forecast_results['ds'] = pd.to_datetime(forecast_results['ds'])

# Convert day numbers to names for better readability
day_map = {
    0: 'Monday',
    1: 'Tuesday',
    2: 'Wednesday',
    3: 'Thursday',
    4: 'Friday',
    5: 'Saturday',
    6: 'Sunday'
}

if 'day_of_week' in heatmap_data.columns:
    heatmap_data['day_name'] = heatmap_data['day_of_week'].map(day_map)

if 'day_of_week' in monthly_heatmap.columns:
    monthly_heatmap['day_name'] = monthly_heatmap['day_of_week'].map(day_map)

# Month mapping
month_map = {
    1: 'January',
    2: 'February',
    3: 'March',
    4: 'April',
    5: 'May',
    6: 'June',
    7: 'July',
    8: 'August',
    9: 'September',
    10: 'October',
    11: 'November',
    12: 'December'
}

if 'scheduled_month' in monthly_heatmap.columns:
    monthly_heatmap['month_name'] = monthly_heatmap['scheduled_month'].map(month_map)

# Create Dashboard App
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Define dashboard layout
app.layout = dbc.Container([
    dbc.Row([
        dbc.Col([
            html.H1("Facility Management Task Dashboard", className="text-center mb-4"),
            html.P("Analyze task completion patterns and predict missed tasks", className="text-center mb-4"),
        ], width=12)
    ]),
    
    # Filters Row
    dbc.Row([
        dbc.Col([
            html.H4("Filters", className="text-center"),
            html.Div([
                html.Label("Date Range:"),
                dcc.DatePickerRange(
                    id='date-range',
                    start_date=daily_stats['date'].min() if 'date' in daily_stats.columns else None,
                    end_date=daily_stats['date'].max() if 'date' in daily_stats.columns else None,
                    className="mb-2"
                ),
            ]),
            html.Div([
                html.Label("Team:"),
                dcc.Dropdown(
                    id='team-filter',
                    options=[{'label': team, 'value': team} for team in team_stats['team'].unique()],
                    value='All',
                    className="mb-2"
                ),
            ]),
            html.Div([
                html.Label("Building:"),
                dcc.Dropdown(
                    id='building-filter',
                    options=[{'label': building, 'value': building} for building in building_stats['building'].unique()],
                    value='All',
                    className="mb-2"
                ),
            ]),
            html.Div([
                html.Label("Task Type:"),
                dcc.Dropdown(
                    id='task-type-filter',
                    options=[{'label': task_type, 'value': task_type} for task_type in task_type_stats['task_type'].unique()],
                    value='All',
                    className="mb-2"
                ),
            ]),
            html.Div([
                dbc.Button("Apply Filters", id="apply-filters", color="primary", className="w-100 mt-3")
            ])
        ], width=3),
        
        # Main content area
        dbc.Col([
            # Summary Statistics Cards
            dbc.Row([
                dbc.Col([
                    dbc.Card([
                        dbc.CardBody([
                            html.H5("Average Task Miss Rate", className="card-title text-center"),
                            html.H3(id="avg-miss-rate", className="text-center text-danger"),
                        ])
                    ])
                ]),
                dbc.Col([
                    dbc.Card([
                        dbc.CardBody([
                            html.H5("Total Tasks", className="card-title text-center"),
                            html.H3(id="total-tasks", className="text-center"),
                        ])
                    ])
                ]),
                dbc.Col([
                    dbc.Card([
                        dbc.CardBody([
                            html.H5("On-Time Completion Rate", className="card-title text-center"),
                            html.H3(id="on-time-rate", className="text-center text-success"),
                        ])
                    ])
                ]),
                dbc.Col([
                    dbc.Card([
                        dbc.CardBody([
                            html.H5("Anomalies Detected", className="card-title text-center"),
                            html.H3(id="anomalies-count", className="text-center text-warning"),
                        ])
                    ])
                ]),
            ], className="mb-4"),
            
            # Trend Charts
            dbc.Row([
                dbc.Col([
                    dbc.Card([
                        dbc.CardHeader("Task Miss Rate Trend"),
                        dbc.CardBody([
                            dcc.Graph(id="miss-rate-trend"),
                        ]),
                        dbc.CardFooter(id="miss-rate-trend-insights", className="text-muted"),
                    ])
                ], width=12),
            ], className="mb-4"),
            
            # Hourly Heatmap and Task Type Performance
            dbc.Row([
                dbc.Col([
                    dbc.Card([
                        dbc.CardHeader("Task Miss Rate by Day & Hour"),
                        dbc.CardBody([
                            dcc.Graph(id="hourly-heatmap"),
                        ]),
                        dbc.CardFooter(id="hourly-heatmap-insights", className="text-muted"),
                    ])
                ], width=6),
                dbc.Col([
                    dbc.Card([
                        dbc.CardHeader("Task Type Performance"),
                        dbc.CardBody([
                            dcc.Graph(id="task-type-performance"),
                        ]),
                        dbc.CardFooter(id="task-type-insights", className="text-muted"),
                    ])
                ], width=6),
            ], className="mb-4"),
            
            # Team Performance and Feature Importance
            dbc.Row([
                dbc.Col([
                    dbc.Card([
                        dbc.CardHeader("Team Performance"),
                        dbc.CardBody([
                            dcc.Graph(id="team-performance"),
                        ]),
                        dbc.CardFooter(id="team-insights", className="text-muted"),
                    ])
                ], width=6),
                dbc.Col([
                    dbc.Card([
                        dbc.CardHeader("Key Factors Affecting Task Completion"),
                        dbc.CardBody([
                            dcc.Graph(id="feature-importance"),
                        ]),
                        dbc.CardFooter(id="feature-importance-insights", className="text-muted"),
                    ])
                ], width=6),
            ], className="mb-4"),
            
            # Forecast and Monthly Heatmap
            dbc.Row([
                dbc.Col([
                    dbc.Card([
                        dbc.CardHeader("30-Day Miss Rate Forecast"),
                        dbc.CardBody([
                            dcc.Graph(id="miss-rate-forecast"),
                        ]),
                        dbc.CardFooter(id="forecast-insights", className="text-muted"),
                    ])
                ], width=6),
                dbc.Col([
                    dbc.Card([
                        dbc.CardHeader("Monthly Miss Rate Patterns"),
                        dbc.CardBody([
                            dcc.Graph(id="monthly-heatmap"),
                        ]),
                        dbc.CardFooter(id="monthly-heatmap-insights", className="text-muted"),
                    ])
                ], width=6),
            ], className="mb-4"),
            
            # Anomaly Detection
            dbc.Row([
                dbc.Col([
                    dbc.Card([
                        dbc.CardHeader("Anomaly Detection in Task Misses"),
                        dbc.CardBody([
                            dcc.Graph(id="anomaly-detection"),
                        ]),
                        dbc.CardFooter(id="anomaly-insights", className="text-muted"),
                    ])
                ], width=12),
            ], className="mb-4"),
        ], width=9)
    ]),
    
    # Footer
    dbc.Row([
        dbc.Col([
            html.Hr(),
            html.P("Facility Management Dashboard - Built with Dash and Plotly", className="text-center text-muted"),
        ], width=12)
    ]),
], fluid=True)

# Define callbacks for interactivity
@app.callback(
    [Output("avg-miss-rate", "children"),
     Output("total-tasks", "children"),
     Output("on-time-rate", "children"),
     Output("anomalies-count", "children"),
     Output("miss-rate-trend", "figure"),
     Output("hourly-heatmap", "figure"),
     Output("task-type-performance", "figure"),
     Output("team-performance", "figure"),
     Output("feature-importance", "figure"),
     Output("miss-rate-forecast", "figure"),
     Output("monthly-heatmap", "figure"),
     Output("anomaly-detection", "figure"),
     Output("miss-rate-trend-insights", "children"),
     Output("hourly-heatmap-insights", "children"),
     Output("task-type-insights", "children"),
     Output("team-insights", "children"),
     Output("feature-importance-insights", "children"),
     Output("forecast-insights", "children"),
     Output("monthly-heatmap-insights", "children"),
     Output("anomaly-insights", "children")],
    [Input("apply-filters", "n_clicks")],
    [State("date-range", "start_date"),
     State("date-range", "end_date"),
     State("team-filter", "value"),
     State("building-filter", "value"),
     State("task-type-filter", "value")]
)
def update_dashboard(n_clicks, start_date, end_date, team, building, task_type):
    # This function updates all dashboard components based on the selected filters
    
    # Convert strings to dates if needed
    if start_date:
        start_date = pd.to_datetime(start_date)
    if end_date:
        end_date = pd.to_datetime(end_date)
    
    # Filter daily stats by date if necessary
    if 'date' in daily_stats.columns and start_date and end_date:
        filtered_daily = daily_stats[(daily_stats['date'] >= start_date) & 
                                    (daily_stats['date'] <= end_date)]
    else:
        filtered_daily = daily_stats.copy()
    
    # Calculate summary statistics
    avg_miss_rate = f"{filtered_daily['miss_rate'].mean():.1f}%"
    total_tasks = f"{int(filtered_daily['task_count'].sum()):,}"
    on_time_rate = f"{filtered_daily['on_time_rate'].mean():.1f}%"
    
    if 'anomaly' in anomaly_results.columns:
        anomalies = anomaly_results[anomaly_results['anomaly'] == 1]
        if 'scheduled_date' in anomaly_results.columns and start_date and end_date:
            anomalies = anomalies[(anomalies['scheduled_date'] >= start_date) & 
                                  (anomalies['scheduled_date'] <= end_date)]
        anomalies_count = f"{len(anomalies)}"
    else:
        anomalies_count = "N/A"
    
    # Create miss rate trend chart
    miss_trend_fig = px.line(filtered_daily, x='date', y='miss_rate', 
                            title="Task Miss Rate Over Time",
                            labels={"miss_rate": "Miss Rate (%)", "date": "Date"})
    
    miss_trend_fig.update_layout(
        xaxis_title="Date",
        yaxis_title="Miss Rate (%)",
        template="plotly_white"
    )
    
    # Add on-time rate as a second line
    miss_trend_fig.add_trace(
        go.Scatter(
            x=filtered_daily['date'],
            y=filtered_daily['on_time_rate'],
            mode='lines',
            name='On-Time Rate (%)',
            line=dict(color='green')
        )
    )
    
    # Hourly heatmap
    hourly_heatmap_fig = px.density_heatmap(
        heatmap_data, 
        x='scheduled_hour', 
        y='day_name',
        z='miss_rate',
        title="Task Miss Rate by Day and Hour",
        labels={"miss_rate": "Miss Rate (%)", 
                "scheduled_hour": "Hour of Day", 
                "day_name": "Day of Week"},
        color_continuous_scale="Viridis_r"  # Reversed so darker = higher miss rate
    )
    
    hourly_heatmap_fig.update_layout(
        xaxis_title="Hour of Day",
        yaxis_title="Day of Week",
        template="plotly_white"
    )
    
    # Task type performance
    task_type_fig = px.bar(
        task_type_stats.sort_values('miss_rate', ascending=False), 
        x='task_type', 
        y='miss_rate',
        title="Task Miss Rate by Task Type",
        labels={"miss_rate": "Miss Rate (%)", "task_type": "Task Type"},
        color='miss_rate',
        color_continuous_scale="Viridis_r"
    )
    
    task_type_fig.update_layout(
        xaxis_title="Task Type",
        yaxis_title="Miss Rate (%)",
        template="plotly_white",
        xaxis={'categoryorder':'total descending'}
    )
    
    # Add a size dimension based on task count
    task_type_fig.update_traces(marker=dict(
        color=task_type_stats.sort_values('miss_rate', ascending=False)['task_count'],  
        colorscale="Viridis_r"
    ))
    
    # Team performance
    team_fig = px.bar(
        team_stats.sort_values('miss_rate'), 
        x='team', 
        y='miss_rate',
        title="Team Performance (Miss Rates)",
        labels={"miss_rate": "Miss Rate (%)", "team": "Team"},
        color='miss_rate',
        color_continuous_scale="Viridis_r"
    )
    
    team_fig.update_layout(
        xaxis_title="Team",
        yaxis_title="Miss Rate (%)",
        template="plotly_white"
    )
    
    # Feature importance chart
    if feature_importance is not None:
        feature_imp_fig = px.bar(
            feature_importance.head(10), 
            x='importance', 
            y='feature',
            title="Top 10 Factors Affecting Task Completion",
            labels={"importance": "Importance Score", "feature": "Feature"},
            color='importance',
            orientation='h'
        )
        
        feature_imp_fig.update_layout(
            xaxis_title="Importance Score",
            yaxis_title="Feature",
            template="plotly_white",
            yaxis={'categoryorder':'total ascending'}
        )
    else:
        # Dummy plot if no feature importance data
        feature_imp_fig = px.bar(
            pd.DataFrame({'feature': ['No data'], 'importance': [0]}),
            x='importance',
            y='feature',
            title="Feature Importance Data Not Available"
        )
    
    # Forecast chart
    forecast_fig = go.Figure()
    
    if 'ds' in forecast_results.columns and 'yhat' in forecast_results.columns:
        # Add forecast line
        forecast_fig.add_trace(go.Scatter(
            x=forecast_results['ds'],
            y=forecast_results['yhat'],
            mode='lines',
            name='Forecast',
            line=dict(color='blue')
        ))
        
        # Add uncertainty interval if available
        if 'yhat_lower' in forecast_results.columns and 'yhat_upper' in forecast_results.columns:
            forecast_fig.add_trace(go.Scatter(
                x=forecast_results['ds'],
                y=forecast_results['yhat_upper'],
                mode='lines',
                name='Upper Bound',
                line=dict(width=0),
                showlegend=False
            ))
            
            forecast_fig.add_trace(go.Scatter(
                x=forecast_results['ds'],
                y=forecast_results['yhat_lower'],
                mode='lines',
                name='Lower Bound',
                line=dict(width=0),
                fill='tonexty',
                fillcolor='rgba(0, 0, 255, 0.1)',
                showlegend=False
            ))
    else:
        # Dummy plot
        forecast_fig.add_trace(go.Scatter(
            x=[datetime.now(), datetime.now() + timedelta(days=30)],
            y=[15, 15],
            mode='lines',
            name='Forecast'
        ))
    
    forecast_fig.update_layout(
        title="30-Day Task Miss Rate Forecast",
        xaxis_title="Date",
        yaxis_title="Miss Rate (%)",
        template="plotly_white"
    )
    
    # Monthly heatmap
    monthly_heatmap_fig = px.density_heatmap(
        monthly_heatmap, 
        x='month_name' if 'month_name' in monthly_heatmap.columns else 'scheduled_month', 
        y='day_name' if 'day_name' in monthly_heatmap.columns else 'day_of_week',
        z='miss_rate',
        title="Task Miss Rate by Month and Day",
        labels={"miss_rate": "Miss Rate (%)", 
                "month_name": "Month", 
                "day_name": "Day of Week"},
        color_continuous_scale="Viridis_r"
    )
    
    monthly_heatmap_fig.update_layout(
        xaxis_title="Month",
        yaxis_title="Day of Week",
        template="plotly_white"
    )
    
    # Anomaly detection chart
    anomaly_fig = go.Figure()
    
    if 'scheduled_date' in anomaly_results.columns and 'task_missed' in anomaly_results.columns:
        # Add normal points
        normal_points = anomaly_results[anomaly_results['anomaly'] == 0]
        anomaly_fig.add_trace(go.Scatter(
            x=normal_points['scheduled_date'],
            y=normal_points['task_missed'] * 100,  # Convert to percentage
            mode='markers',
            name='Normal',
            marker=dict(color='blue', size=8)
        ))
        
        # Add anomaly points
        anomaly_points = anomaly_results[anomaly_results['anomaly'] == 1]
        anomaly_fig.add_trace(go.Scatter(
            x=anomaly_points['scheduled_date'],
            y=anomaly_points['task_missed'] * 100,  # Convert to percentage
            mode='markers',
            name='Anomaly',
            marker=dict(color='red', size=12, symbol='circle-open')
        ))
    else:
        # Dummy plot
        anomaly_fig.add_trace(go.Scatter(
            x=[datetime.now() - timedelta(days=i) for i in range(30)],
            y=np.random.uniform(10, 20, 30),
            mode='markers',
            name='Data Points'
        ))
    
    anomaly_fig.update_layout(
        title="Anomaly Detection in Daily Task Miss Rates",
        xaxis_title="Date",
        yaxis_title="Miss Rate (%)",
        template="plotly_white"
    )
    
    # Generate insights
    # Miss rate trend insights
    if len(filtered_daily) > 0:
        recent_trend = filtered_daily.iloc[-5:]['miss_rate'].mean() - filtered_daily.iloc[-10:-5]['miss_rate'].mean()
        if recent_trend > 2:
            trend_insight = f"⚠️ Warning: Task miss rate has increased by {recent_trend:.1f}% in the last period. Consider reviewing workload distribution."
        elif recent_trend < -2:
            trend_insight = f"✅ Positive trend: Task miss rate has decreased by {abs(recent_trend):.1f}% in the last period."
        else:
            trend_insight = "Task miss rate has remained relatively stable in the recent period."
    else:
        trend_insight = "Insufficient data to generate insights."
    
    # Hourly heatmap insights
    if len(heatmap_data) > 0:
        worst_hour = heatmap_data.loc[heatmap_data['miss_rate'].idxmax()]
        heatmap_insight = f"Highest miss rates occur on {worst_hour['day_name']} at {int(worst_hour['scheduled_hour'])}:00 ({worst_hour['miss_rate']:.1f}%). Consider adjusting staffing or workload for this time slot."
    else:
        heatmap_insight = "Insufficient data to generate insights."
    
    # Task type insights
    if len(task_type_stats) > 0:
        worst_task = task_type_stats.loc[task_type_stats['miss_rate'].idxmax()]
        task_insight = f"'{worst_task['task_type']}' has the highest miss rate at {worst_task['miss_rate']:.1f}%. This task type may require additional resources or process improvements."
    else:
        task_insight = "Insufficient data to generate insights."
    
    # Team insights
    if len(team_stats) > 0:
        best_team = team_stats.loc[team_stats['miss_rate'].idxmin()]
        worst_team = team_stats.loc[team_stats['miss_rate'].idxmax()]
        team_insight = f"'{best_team['team']}' has the lowest miss rate ({best_team['miss_rate']:.1f}%), while '{worst_team['team']}' has the highest ({worst_team['miss_rate']:.1f}%). Consider knowledge sharing between teams."
    else:
        team_insight = "Insufficient data to generate insights."
    
    # Feature importance insights
    if feature_importance is not None and len(feature_importance) > 0:
        top_feature = feature_importance.iloc[0]
        feature_insight = f"'{top_feature['feature']}' is the most important factor affecting task completion. Focus improvement efforts on this aspect to reduce missed tasks."
    else:
        feature_insight = "Feature importance data not available."
    
    # Forecast insights
    if 'yhat' in forecast_results.columns:
        current_rate = filtered_daily['miss_rate'].iloc[-1] if len(filtered_daily) > 0 else 0
        future_rate = forecast_results['yhat'].iloc[-1]
        rate_change = future_rate - current_rate
        
        if rate_change > 2:
            forecast_insight = f"⚠️ Forecast shows an increasing trend in miss rates (projected {rate_change:.1f}% increase). Proactive measures recommended."
        elif rate_change < -2:
            forecast_insight = f"✅ Forecast shows improvements in miss rates (projected {abs(rate_change):.1f}% decrease)."
        else:
            forecast_insight = "Forecast indicates stable miss rates for the upcoming period."
# Forecast insights (continuing from where the previous code was cut off)
    else:
        forecast_insight = "Forecast data not available for analysis."
    
    # Monthly heatmap insights
    if len(monthly_heatmap) > 0:
        worst_month_day = monthly_heatmap.loc[monthly_heatmap['miss_rate'].idxmax()]
        if 'month_name' in monthly_heatmap.columns and 'day_name' in monthly_heatmap.columns:
            month_insight = f"The highest miss rates occur in {worst_month_day['month_name']} on {worst_month_day['day_name']}s ({worst_month_day['miss_rate']:.1f}%). Plan for increased staffing during this period."
        else:
            month_insight = f"The highest miss rates occur in month {worst_month_day['scheduled_month']} on day {worst_month_day['day_of_week']} ({worst_month_day['miss_rate']:.1f}%). Plan for increased staffing during this period."
    else:
        month_insight = "Monthly pattern data not available."
    
    # Anomaly insights
    if 'anomaly' in anomaly_results.columns:
        anomaly_count = len(anomaly_results[anomaly_results['anomaly'] == 1])
        if anomaly_count > 0:
            anomaly_insight = f"Detected {anomaly_count} anomalous days with unusually high miss rates. Investigate these dates for special circumstances or resource constraints."
        else:
            anomaly_insight = "No significant anomalies detected in the task miss patterns."
    else:
        anomaly_insight = "Anomaly detection data not available."
    
    return (
        avg_miss_rate,
        total_tasks,
        on_time_rate,
        anomalies_count,
        miss_trend_fig,
        hourly_heatmap_fig,
        task_type_fig,
        team_fig,
        feature_imp_fig,
        forecast_fig,
        monthly_heatmap_fig,
        anomaly_fig,
        trend_insight,
        heatmap_insight,
        task_insight,
        team_insight,
        feature_insight,
        forecast_insight,
        month_insight,
        anomaly_insight
    )

# Task prediction function
def predict_task_miss_probability(model_data, task_data):
    """
    Predict the probability of a task being missed based on task attributes.
    
    Args:
        model_data: Dictionary containing model and preprocessing components
        task_data: Dictionary containing task attributes
        
    Returns:
        float: Probability of task being missed (0-100%)
    """
    # This is a placeholder for a real prediction function
    # In practice, you would:
    # 1. Extract the model features from task_data
    # 2. Preprocess using the same pipeline as during training
    # 3. Make a prediction with the model
    
    # For demonstration purposes, return a random value
    return np.random.uniform(0, 100)

# Add a callback for a new task prediction functionality
@app.callback(
    Output("prediction-result", "children"),
    [Input("predict-button", "n_clicks")],
    [State("task-type-input", "value"),
     State("team-input", "value"),
     State("building-input", "value"),
     State("priority-input", "value"),
     State("complexity-input", "value"),
     State("duration-input", "value"),
     State("concurrent-tasks-input", "value"),
     State("resource-availability-input", "value")]
)
def predict_new_task(n_clicks, task_type, team, building, priority, complexity, duration, concurrent_tasks, resource_availability):
    if n_clicks is None:
        return "Enter task details and click 'Predict' to see the miss probability."
    
    # Create task data dictionary
    task_data = {
        'task_type': task_type,
        'team': team,
        'building': building,
        'priority': priority,
        'task_complexity': float(complexity),
        'estimated_duration': float(duration),
        'concurrent_tasks': int(concurrent_tasks),
        'resource_availability': float(resource_availability)
    }
    
    # Get prediction
    miss_probability = predict_task_miss_probability(model_data, task_data)
    
    # Generate recommendation based on risk level
    if miss_probability < 20:
        risk_level = "Low"
        recommendation = "Standard scheduling is appropriate."
        color = "success"
    elif miss_probability < 50:
        risk_level = "Medium"
        recommendation = "Consider assigning additional resources or adjusting the schedule."
        color = "warning"
    else:
        risk_level = "High"
        recommendation = "High risk of missing this task. Consider priority adjustment, additional resources, or rescheduling."
        color = "danger"
    
    return [
        html.H4(f"Miss Probability: {miss_probability:.1f}%", className=f"text-{color}"),
        html.P(f"Risk Level: {risk_level}", className=f"text-{color}"),
        html.P(f"Recommendation: {recommendation}")
    ]

# Add a prediction form to the layout
prediction_form = html.Div([
    dbc.Card([
        dbc.CardHeader("Task Miss Prediction"),
        dbc.CardBody([
            dbc.Row([
                dbc.Col([
                    html.Label("Task Type:"),
                    dcc.Dropdown(
                        id="task-type-input",
                        options=[{'label': task, 'value': task} for task in task_type_stats['task_type']],
                        value=task_type_stats['task_type'].iloc[0] if len(task_type_stats) > 0 else None
                    )
                ], width=6),
                dbc.Col([
                    html.Label("Team:"),
                    dcc.Dropdown(
                        id="team-input",
                        options=[{'label': team, 'value': team} for team in team_stats['team']],
                        value=team_stats['team'].iloc[0] if len(team_stats) > 0 else None
                    )
                ], width=6)
            ], className="mb-2"),
            dbc.Row([
                dbc.Col([
                    html.Label("Building:"),
                    dcc.Dropdown(
                        id="building-input",
                        options=[{'label': building, 'value': building} for building in building_stats['building']],
                        value=building_stats['building'].iloc[0] if len(building_stats) > 0 else None
                    )
                ], width=6),
                dbc.Col([
                    html.Label("Priority:"),
                    dcc.Dropdown(
                        id="priority-input",
                        options=[
                            {'label': 'Low', 'value': 'Low'},
                            {'label': 'Medium', 'value': 'Medium'},
                            {'label': 'High', 'value': 'High'},
                            {'label': 'Critical', 'value': 'Critical'}
                        ],
                        value="Medium"
                    )
                ], width=6)
            ], className="mb-2"),
            dbc.Row([
                dbc.Col([
                    html.Label("Task Complexity (1-10):"),
                    dcc.Input(
                        id="complexity-input",
                        type="number",
                        min=1,
                        max=10,
                        step=0.5,
                        value=5,
                        className="form-control"
                    )
                ], width=6),
                dbc.Col([
                    html.Label("Estimated Duration (hours):"),
                    dcc.Input(
                        id="duration-input",
                        type="number",
                        min=0.5,
                        max=8,
                        step=0.5,
                        value=2,
                        className="form-control"
                    )
                ], width=6)
            ], className="mb-2"),
            dbc.Row([
                dbc.Col([
                    html.Label("Concurrent Tasks:"),
                    dcc.Input(
                        id="concurrent-tasks-input",
                        type="number",
                        min=0,
                        max=20,
                        step=1,
                        value=3,
                        className="form-control"
                    )
                ], width=6),
                dbc.Col([
                    html.Label("Resource Availability (0-1):"),
                    dcc.Input(
                        id="resource-availability-input",
                        type="number",
                        min=0,
                        max=1,
                        step=0.1,
                        value=0.8,
                        className="form-control"
                    )
                ], width=6)
            ], className="mb-3"),
            dbc.Button("Predict", id="predict-button", color="primary", className="w-100"),
            html.Div(id="prediction-result", className="mt-3")
        ])
    ])
])

# Add the prediction form to the layout
app.layout.children[1].children[0].children.append(prediction_form)

# Add Resource Optimization Dashboard

def calculate_optimal_resources(building_workload, current_miss_rate, target_miss_rate=0.05):
    """
    Calculate the optimal resource allocation to reach target miss rate.
    """
    # This is a simplified model. In practice, you would use actual ML predictions
    # to recommend optimal staffing levels
    
    # Assume linear relationship between resources and miss rate
    current_resources = 100  # baseline
    
    # If current miss rate is higher than target, increase resources
    if current_miss_rate > target_miss_rate:
        resource_factor = current_miss_rate / target_miss_rate
        optimal_resources = current_resources * resource_factor
    else:
        # If already meeting targets, minor adjustment
        optimal_resources = current_resources * 0.95
    
    # Adjust based on workload
    workload_factor = building_workload / 500  # normalize
    optimal_resources = optimal_resources * (1 + workload_factor)
    
    return round(optimal_resources)

# Resource optimization dashboard
resource_optimization = html.Div([
    dbc.Card([
        dbc.CardHeader("Resource Optimization Recommendations"),
        dbc.CardBody([
            html.Div([
                html.H5("Recommended Team Allocations to Reduce Miss Rates"),
                dcc.Graph(id="resource-recommendation")
            ]),
            html.Div(id="resource-insights", className="mt-3")
        ])
    ])
])

# Add the resource optimization to the layout
app.layout.children[1].children[1].children.append(
    dbc.Row([
        dbc.Col([resource_optimization], width=12)
    ], className="mb-4")
)

@app.callback(
    [Output("resource-recommendation", "figure"),
     Output("resource-insights", "children")],
    [Input("apply-filters", "n_clicks")],
    [State("building-filter", "value")]
)
def update_resource_recommendations(n_clicks, building):
    # Generate resource recommendations based on current miss rates
    
    # Create sample resource data (in a real system, this would be ML-based)
    if building != 'All' and building in building_stats['building'].values:
        buildings_to_show = [building]
    else:
        buildings_to_show = building_stats['building'].tolist()
    
    resource_data = []
    for bldg in buildings_to_show:
        bldg_stats = building_stats[building_stats['building'] == bldg].iloc[0]
        miss_rate = bldg_stats['miss_rate'] / 100  # Convert to decimal
        workload = bldg_stats['task_count']
        
        optimal_resources = calculate_optimal_resources(workload, miss_rate)
        current_resources = optimal_resources * (0.7 + np.random.uniform(0, 0.3))  # Simulate current resources
        
        resource_data.append({
            'building': bldg,
            'current_resources': int(current_resources),
            'optimal_resources': optimal_resources,
            'resource_gap': optimal_resources - int(current_resources)
        })
    
    resource_df = pd.DataFrame(resource_data)
    
    # Create the recommendation plot
    fig = go.Figure()
    
    # Add Current Resources bars
    fig.add_trace(go.Bar(
        x=resource_df['building'],
        y=resource_df['current_resources'],
        name='Current Resources',
        marker_color='lightblue'
    ))
    
    # Add Optimal Resources bars
    fig.add_trace(go.Bar(
        x=resource_df['building'],
        y=resource_df['optimal_resources'],
        name='Recommended Resources',
        marker_color='darkblue'
    ))
    
    fig.update_layout(
        title="Resource Allocation by Building",
        xaxis_title="Building",
        yaxis_title="Resource Units",
        barmode='group',
        template="plotly_white"
    )
    
    # Generate insights
    insights = []
    total_gap = resource_df['resource_gap'].sum()
    
    if total_gap > 0:
        insights.append(html.P(f"Analysis suggests a resource deficit of {int(total_gap)} units across all buildings."))
    
    # Building-specific recommendations
    for _, row in resource_df.iterrows():
        if row['resource_gap'] > 5:
            insights.append(html.P([
                html.Strong(f"{row['building']}: "),
                f"Recommend adding {int(row['resource_gap'])} resource units to reduce miss rates."
            ]))
        elif row['resource_gap'] < -5:
            insights.append(html.P([
                html.Strong(f"{row['building']}: "),
                f"Resources may be over-allocated by {int(abs(row['resource_gap']))} units. Consider reallocation."
            ]))
    
    return fig, insights

# Add time-based workload forecasting
workload_forecast = html.Div([
    dbc.Card([
        dbc.CardHeader("Workload Forecasting and Resource Planning"),
        dbc.CardBody([
            html.Div([
                html.H5("Projected Workload Distribution (Next 30 Days)"),
                dcc.Graph(id="workload-forecast")
            ]),
            html.Div(id="workload-insights", className="mt-3")
        ])
    ])
])

# Add the workload forecast to the layout
app.layout.children[1].children[1].children.append(
    dbc.Row([
        dbc.Col([workload_forecast], width=12)
    ], className="mb-4")
)

@app.callback(
    [Output("workload-forecast", "figure"),
     Output("workload-insights", "children")],
    [Input("apply-filters", "n_clicks")]
)
def update_workload_forecast(n_clicks):
    # Generate forecast for the next 30 days
    end_date = datetime.now().date()
    start_date = end_date + timedelta(days=1)
    forecast_end = end_date + timedelta(days=30)
    
    # Create date range for forecast
    forecast_dates = pd.date_range(start=start_date, end=forecast_end)
    
    # Model weekday patterns (more tasks on weekdays)
    weekday_factor = [1.2, 1.3, 1.4, 1.3, 1.2, 0.7, 0.6]  # Mon-Sun
    
    # Generate workload forecast with weekday patterns
    forecast_data = []
    for date in forecast_dates:
        day_of_week = date.dayofweek
        
        # Base workload with weekday pattern
        base_workload = 50 * weekday_factor[day_of_week]
        
        # Add some randomness
        workload = base_workload * (1 + np.random.uniform(-0.1, 0.1))
        
        # Seasonal factor (more tasks in winter/summer)
        month = date.month
        seasonal_factor = 1.0 + 0.2 * abs((month - 6.5) / 5.5)
        workload = workload * seasonal_factor
        
        # Create forecast record
        forecast_data.append({
            'date': date,
            'projected_workload': int(workload),
            'day_of_week': day_of_week
        })
    
    forecast_df = pd.DataFrame(forecast_data)
    forecast_df['day_name'] = forecast_df['day_of_week'].map(day_map)
    
    # Create workload forecast figure
    fig = go.Figure()
    
    # Add projected workload line
    fig.add_trace(go.Scatter(
        x=forecast_df['date'],
        y=forecast_df['projected_workload'],
        mode='lines+markers',
        name='Projected Workload',
        line=dict(color='blue')
    ))
    
    # Highlight weekends differently
    weekend_df = forecast_df[forecast_df['day_of_week'].isin([5, 6])]
    fig.add_trace(go.Scatter(
        x=weekend_df['date'],
        y=weekend_df['projected_workload'],
        mode='markers',
        name='Weekend Workload',
        marker=dict(color='red', size=10)
    ))
    
    # Add capacity reference line (assuming capacity = 60)
    capacity = 60
    fig.add_trace(go.Scatter(
        x=forecast_df['date'],
        y=[capacity] * len(forecast_df),
        mode='lines',
        name='Current Capacity',
        line=dict(color='green', dash='dash')
    ))
    
    fig.update_layout(
        title="30-Day Workload Forecast",
        xaxis_title="Date",
        yaxis_title="Projected Tasks",
        template="plotly_white"
    )
    
    # Generate insights
    high_load_days = forecast_df[forecast_df['projected_workload'] > capacity]
    high_load_count = len(high_load_days)
    
    insights = []
    
    if high_load_count > 0:
        insights.append(html.P(f"Projected capacity shortage on {high_load_count} days in the next month."))
        
        # Group high load days by day of week
        day_counts = high_load_days['day_name'].value_counts()
        most_common_day = day_counts.index[0] if len(day_counts) > 0 else "N/A"
        
        insights.append(html.P([
            "Highest workloads typically occur on ",
            html.Strong(f"{most_common_day}s"),
            ". Consider increasing staffing on these days."
        ]))
        
        # Find the highest workload date
        max_load_date = high_load_days.loc[high_load_days['projected_workload'].idxmax()]
        insights.append(html.P([
            "Peak workload expected on ",
            html.Strong(f"{max_load_date['date'].strftime('%Y-%m-%d')} ({max_load_date['day_name']})"),
            f" with {int(max_load_date['projected_workload'])} tasks (vs. capacity of {capacity})."
        ]))
    else:
        insights.append(html.P("Current resource capacity appears sufficient for the projected workload."))
    
    average_workload = forecast_df['projected_workload'].mean()
    insights.append(html.P(f"Average daily workload forecast: {average_workload:.1f} tasks."))
    
    return fig, insights

# Add customization options for the dashboard
customization_options = html.Div([
    dbc.Collapse([
        dbc.Card([
            dbc.CardHeader("Dashboard Settings"),
            dbc.CardBody([
                html.H5("Chart Settings"),
                dbc.Row([
                    dbc.Col([
                        html.Label("Color Theme:"),
                        dcc.Dropdown(
                            id="color-theme",
                            options=[
                                {'label': 'Default', 'value': 'plotly'},
                                {'label': 'Light', 'value': 'plotly_white'},
                                {'label': 'Dark', 'value': 'plotly_dark'},
                                {'label': 'Presentation', 'value': 'presentation'}
                            ],
                            value='plotly_white',
                            className="mb-2"
                        ),
                    ], width=6),
                    dbc.Col([
                        html.Label("Chart Format:"),
                        dcc.Dropdown(
                            id="chart-format",
                            options=[
                                {'label': 'Interactive', 'value': 'interactive'},
                                {'label': 'Static (Better Performance)', 'value': 'static'}
                            ],
                            value='interactive',
                            className="mb-2"
                        ),
                    ], width=6)
                ]),
                html.H5("Data Settings", className="mt-3"),
                dbc.Row([
                    dbc.Col([
                        html.Label("Data Refresh Interval:"),
                        dcc.Dropdown(
                            id="refresh-interval",
                            options=[
                                {'label': 'Real-time (10s)', 'value': 10000},
                                {'label': '1 minute', 'value': 60000},
                                {'label': '5 minutes', 'value': 300000},
                                {'label': 'Manual refresh only', 'value': 0}
                            ],
                            value=0,
                            className="mb-2"
                        ),
                    ], width=6),
                    dbc.Col([
                        html.Label("Anomaly Detection Sensitivity:"),
                        dcc.Slider(
                            id="anomaly-sensitivity",
                            min=0.01,
                            max=0.1,
                            step=0.01,
                            value=0.05,
                            marks={i/100: str(i) + '%' for i in range(1, 11, 3)},
                            className="mb-2"
                        ),
                    ], width=6)
                ]),
                dbc.Button("Apply Settings", id="apply-settings", color="primary", className="mt-3")
            ])
        ])
    ], id="settings-collapse", is_open=False),
    dbc.Button(
        "Dashboard Settings",
        id="settings-button",
        color="secondary",
        className="mt-3 mb-3"
    )
])

# Add the customization options to the layout
app.layout.children.insert(2, customization_options)

@app.callback(
    Output("settings-collapse", "is_open"),
    [Input("settings-button", "n_clicks")],
    [State("settings-collapse", "is_open")]
)
def toggle_settings(n_clicks, is_open):
    if n_clicks:
        return not is_open
    return is_open

# Run the app
if __name__ == '__main__':
    app.run(debug=True)